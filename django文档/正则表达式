Python正则表达式
正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。
Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。
re 模块使 Python 语言拥有全部的正则表达式功能。
compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。
re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。
验证匹配正整数实例：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/验证匹配正整数正则表达式.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
#匹配正整数
import re  
str=r'^[1-9]\d*$'  
if re.match(str,'163'):  #OK
  print('OK')
else:
  print('No')       
codeend
常用正则表达式大全
code####start
[, ]+  //匹配一个或连续逗号空格
/(\d+)_([^/]+)$ 匹配  /连续的0-9数_除/以外的字符串 例如：/163_good
匹配特定数字：
^[1-9]d*$　 　 //匹配正整数
^-[1-9]d*$ 　 //匹配负整数
^-?[1-9]d*$　　 //匹配整数
^[1-9]d*|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0）
^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数
^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数
^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数
^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）

/^-?\d+$/g            //等于整数
 /-?\d+/g             //匹配（包含）整数
//匹配（包含）
/\d/g --  /[0-9]/g    // 从0到9的数字
/\d+/g　　             //正整数
/-\d+/g　　            //负整数
/\d+/g 　　            //非负整数（正整数 + 0）
/-\d+|[0]/g　　        //非正整数（负整数 + 0）
/-\d+\.\d+|[0]/g　    //非负浮点数（正浮点数 + 0）
/\d+\.\d+/　　         //正浮点数
/-\d+\.\d+|[0]/g　　   //非正浮点数（负浮点数 + 0）
/-\d+\.\d+/g　　      //负浮点数
/\d+\.\d\d$/g         //2位小数，正浮点数，0-9数字结尾
/-?\d+\.\d+/g　　     //浮点数（不含 0）
/-?\d+\.\d+|[0]/g     //浮点数（含 0）
/[A-Za-z]+/g         // 由26个英文字母组成的字符串

"^[A-Za-z]+$"　　    //由26个英文字母组成的字符串
"^[A-Z]+$"　　       //由26个英文字母的大写组成的字符串
"^[a-z]+$"　　       //由26个英文字母的小写组成的字符串
"^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串
"^\\w+$"　　//由数字、26个英文字母或者下划线组成的字符串
"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$"　　　　//email地址
"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$"　　//url
　
匹配特定字符串：
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串

   匹配中文字符的正则表达式： [u4e00-u9fa5]  
　　评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
　　匹配双字节字符(包括汉字在内)：[^x00-xff]
　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
　　匹配空白行的正则表达式：ns*r
　　评注：可以用来删除空白行
　　匹配HTML标记的正则表达式：<(S*?)[^>]*>.*?|<.*? />
　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
　　匹配首尾空白字符的正则表达式：^s*|s*$
　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
　　匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
　　评注：表单验证时很实用
　　匹配网址URL的正则表达式：[a-zA-z]+://[^s]*
　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求
　　匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
　　评注：表单验证时很实用
　　匹配国内电话号码：d{3}-d{8}|d{4}-d{7}
　　评注：匹配形式如 0511-4405222 或 021-87888822
　　匹配腾讯QQ号：[1-9][0-9]{4,}
　　评注：腾讯QQ号从10000开始
　　匹配中国邮政编码：[1-9]d{5}(?!d)
　　评注：中国邮政编码为6位数字
　　匹配身份证：d{15}|d{18}
　　评注：中国的身份证为15位或18位
　　匹配ip地址：d+.d+.d+.d+
　　评注：提取ip地址时有用
　　在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下:
　　只能输入数字：“^[0-9]*$”
　　只能输入n位的数字：“^d{n}$”
　　只能输入至少n位数字：“^d{n,}$”
　　只能输入m-n位的数字：“^d{m,n}$”
　　只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$”
　　只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$”
　　只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$”
　　只能输入非零的正整数：“^+?[1-9][0-9]*$”
　　只能输入非零的负整数：“^-[1-9][0-9]*$”
　　只能输入长度为3的字符：“^.{3}$”
　　只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$”
　　只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$”
　　只能输入由26个小写英文字母组成的字符串：“^[a-z]+$”
　　只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$”
　　只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”
　　验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间，
　　只能包含字符、数字和下划线。
　　验证是否含有^%&'',;=?$"等字符：“[^%&'',;=?$x22]+”
　　只能输入汉字：“^[u4e00-u9fa5],{0,}$”
　　验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$”
　　验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&=]*)?$”
　　验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$”
　　正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，
　　“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。
　　验证身份证号（15位或18位数字）：“^d{15}|d{}18$”
　　验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”
　　验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”
　　正确格式为：“01”“09”和“1”“31”。
　　匹配中文字符的正则表达式： [u4e00-u9fa5]
　　匹配双字节字符(包括汉字在内)：[^x00-xff]
　　匹配空行的正则表达式：n[s| ]*r
　　匹配HTML标记的正则表达式：/<(.*)>.*|<(.*) />/
　　匹配首尾空格的正则表达式：(^s*)|(s*$)
　　匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
　　匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?
codeend
正则表达式基本语法
code####start
一、()、[]、{} 的区别
() 的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。比如 (\s+) 表示连续空格的字符串。
[]是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示字符文本要匹配英文字符和数字。
{}一般用来表示匹配的长度，比如 _{2} 表示匹配二个以上下划线，_{2,2} 表示匹配二个以上下划线。
二、^ 和 $
^ 匹配一个字符串的开头，比如 (^a) 就是匹配以字母a开头的字符串
$ 匹配一个字符串的结尾,比如 (b$) 就是匹配以字母b结尾的字符串
^ 还有另个一个作用就是取反，比如[^xyz] 表示匹配的字符串不包含xyz
需要注意的是：如果^出现在[]中一般表示取反，而出现在其他地方则是匹配字符串的开头
三、\d  \s  \w  .
\d 匹配一个非负整数， 等价于 [0-9]
\s 匹配一个空白字符
\w 匹配一个英文字母或数字，等价于[0-9a-zA-Z]
.   匹配除换行符以外的任意字符，等价于[^\n]
四、* + ?
* 表示匹配前面元素0次或多次，比如 (\s*) 就是匹配0个或多个空格
+ 表示匹配前面元素1次或多次，比如 (\d+) 就是匹配由至少1个整数组成的字符串
? 表示匹配前面元素0次或1次，相当于{0,1} ，比如(\w?) 就是匹配最多由1个字母或数字组成的字符串
两个特殊的符号'^'和'$'。他们的作用是分别指出一个字符串的开始和结束。例子如下：
"^The"：表示所有以"The"开始的字符串（"There"，"The cat"等）；
"of despair$"：表示所以以"of despair"结尾的字符串；
"^abc$"：表示开始和结尾都是"abc"的字符串——呵呵，只有"abc"自己了；
"notice"：表示任何包含"notice"的字符串。
象最后那个例子，如果你不使用两个特殊字符，你就在表示要查找的串在被查找串的任意部分——你并
不把它定位在某一个顶端。
其它还有'*'，'+'和'?'这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示“没有或
更多”，“一次或更多”还有“没有或一次”。下面是几个例子：
"ab*"：表示一个字符串有一个a后面跟着零个或若干个b。（"a", "ab", "abbb",……）；
"ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多；
"ab?"：表示一个字符串有一个a后面跟着零个或者一个b；
"a?b+$"：表示在字符串的末尾有零个或一个a跟着一个或几个b。
你也可以使用范围，用大括号括起，用以表示重复次数的范围。
"ab{2}"：表示一个字符串有一个a跟着2个b（"abb"）；
"ab{2,}"：表示一个字符串有一个a跟着至少2个b；
"ab{3,5}"：表示一个字符串有一个a跟着3到5个b。
请注意，你必须指定范围的下限（如："{0,2}"而不是"{,2}"）。还有，你可能注意到了，'*'，'+'和
'?'相当于"{0,}"，"{1,}"和"{0,1}"。
还有一个'¦'，表示“或”操作：
"hi¦hello"：表示一个字符串里有"hi"或者"hello"；
"(b¦cd)ef"：表示"bef"或"cdef"；
"(a¦b)*c"：表示一串"a""b"混合的字符串后面跟一个"c"；
'.'可以替代任何字符：
"a.[0-9]"：表示一个字符串有一个"a"后面跟着一个任意字符和一个数字；
"^.{3}$"：表示有任意三个字符的字符串（长度为3个字符）；
方括号表示某些字符允许在一个字符串中的某一特定位置出现：
"[ab]"：表示一个字符串有一个"a"或"b"（相当于"a¦b"）；
"[a-d]"：表示一个字符串包含小写的'a'到'd'中的一个（相当于"a¦b¦c¦d"或者"[abcd]"）；
"^[a-zA-Z]"：表示一个以字母开头的字符串；
"[0-9]%"：表示一个百分号前有一位的数字；
",[a-zA-Z0-9]$"：表示一个字符串以一个逗号后面跟着一个字母或数字结束。
你也可以在方括号里用'^'表示不希望出现的字符，'^'应在方括号里的第一位。（如："%[^a-zA-Z]%"表
示两个百分号中不应该出现字母）。
为了逐字表达，你必须在"^.$()¦*+?{\"这些字符前加上转移字符'\'。
请注意在方括号中，不需要转义字符。
codeend
下面介绍Python中常用的正则表达式处理函数。
re.match函数
re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
函数语法：
code####start
re.match(pattern, string, flags=0)
codeend
函数参数说明：
参数  描述
pattern 匹配的正则表达式
string  要匹配的字符串。
flags   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。
匹配成功re.match方法返回一个匹配的对象，否则返回None。
我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。
<br>
re.match实例1：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/正则表达式不匹配时出错.py">试-下...</a>
code####start
import re
print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配(0, 3) 不匹配时出错
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配None
codeend

re.match实例2：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/正则表达式解析.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
line = "Cats are smarter than dogs"
matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)
if matchObj:
    print "matchObj.group() : ", matchObj.group()
    print "matchObj.group(1) : ", matchObj.group(1)
    print "matchObj.group(2) : ", matchObj.group(2)
else:
    print "No match!!"

运行结果：
matchObj.group() :  Cats are smarter than dogs
matchObj.group(1) :  Cats
matchObj.group(2) :  smarter
codeend
正则表达式：r'(.*) are (.*?) .*'   
解析:
首先，这是一个字符串，前面的一个 r 表示字符串为非转义的原始字符串，让编译器忽略反斜杠，也就是忽略转义字符。但是这个字符串里没有反斜杠，所以这个 r 可有可无。
    (.*) 第一个匹配分组，.* 代表匹配除换行符之外的所有字符。
    (.*?) 第二个匹配分组，.*? 后面多个问号，代表非贪婪模式，也就是说只匹配符合条件的最少字符
    后面的一个 .* 没有括号包围，所以不是分组，匹配效果和第一个一样，但是不计入匹配结果中。
matchObj.group() 等同于 matchObj.group(0)，表示匹配到的完整文本字符
matchObj.group(1) 得到第一组匹配结果，也就是(.*)匹配到的
matchObj.group(2) 得到第二组匹配结果，也就是(.*?)匹配到的
因为只有匹配结果中只有两组，所以如果填 3 时会报错。

re.search方法
re.search 扫描整个字符串并返回第一个成功的匹配。
函数语法：
code####start
re.search(pattern, string, flags=0)
codeend
函数参数说明：
参数  描述
pattern 匹配的正则表达式
string  要匹配的字符串。
flags   标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。
匹配成功re.search方法返回一个匹配的对象，否则返回None。
我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。
匹配对象方法  描述
group(num=0)    匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
groups()    返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。               

re.search实例1：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/正则表达式span会报错.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
print(re.search('g', 'www.run.com')) #None
print(re.search('www', 'www.run.com').span())  # (0, 3)
print(re.search('com', 'www.run.com').span())  # (8, 11)
print(re.search('g', 'www.run.com').span()) #span()匹配不上，会报错
codeend

re.search实例2：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/search正则表达式.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
line = "Cats are smarter than dogs";
searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)
if searchObj:
   print "searchObj.group() : ", searchObj.group()
   print "searchObj.group(1) : ", searchObj.group(1)
   print "searchObj.group(2) : ", searchObj.group(2)
else:
   print "Nothing found!!"
运行结果：
searchObj.group() :  Cats are smarter than dogs
searchObj.group(1) :  Cats
searchObj.group(2) :  smarter
codeend

re.search实例3：字符串转换成列表元组 <a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/字符串转换成列表元组正则表达式.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
myDirList = ['.../.../1_python', '.../.../2_django'] 
aList = [re.search('/(\d+)_([^/]+)',i).groups() for i in myDirList]
print aList
运行结果：
[('1', 'python'), ('2', 'django')]
codeend
re.search实例4：字符串转换成元组 <a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/字符串转元组正则表达式.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
myDirList = '.../.../1_python'
aList = re.search('/(\d+)_([^/]+)',myDirList).groups()
print aList
运行结果：
('1', 'python')
codeend
re.match与re.search的区别
re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
而re.search匹配整个字符串，直到找到一个匹配。
re.search实例1：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/re正则表达式match与search的区别.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
line = "Cats are smarter than dogs";
matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
   print "match --> matchObj.group() : ", matchObj.group()
else:
   print "No match!!"
matchObj = re.search( r'dogs', line, re.M|re.I)
if matchObj:
   print "search --> matchObj.group() : ", matchObj.group()
else:
   print "No match!!"
运行结果：
No match!!
search --> matchObj.group() :  dogs
codeend
检索和替换
Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。
语法：
code####start
re.sub(pattern, repl, string, count=0, flags=0)
codeend
参数：
    pattern : 正则中的模式字符串。
    repl : 替换的字符串，也可为一个函数。
    string : 要被查找替换的原始字符串。
    count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。

re.sub实例1：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/正则表达式sub删除非数字的字符串.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
phone = "2004-959-559 # 这是一个国外电话号码"
# 删除字符串中的 Python注释 
num = re.sub(r'#.*$', "", phone)
print "电话号码是: ", num
# 删除非数字(-)的字符串 
num = re.sub(r'\D', "", phone)
print "电话号码是 : ", num
运行结果：
电话号码是:  2004-959-559 
电话号码是 :  2004959559
codeend 

repl 参数是一个函数
以下实例中将字符串中的匹配的数字乘2：
re.sub实例2：<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/正则表达式将匹配的数字乘2.py">试-下...</a>

code####start
# -*- coding: UTF-8 -*-
import re
# 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
s = 'A23G4HFD567'
print(re.sub('(?P<value>\d+)', double, s)) 
运行结果：
A46G8HFD1134
codeend

使用re.compile
语法：
code####start
compile(pattern [, flags]) 
codeend
re.compile实例：将字符串转换成列表<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/正则表达式匹配一个或连续逗号空格.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
str = 'a,b,, ,,c  d'
reObj = re.compile('[, ]+')
print reObj.split(str)
'''
运行结果：
['a', 'b', 'c', 'd']
解析正则表达式 [, ]+
[ ] 用来表示一组字符
[, ] 匹配字符 逗号','和 空格' '
+ 连续匹配
[, ]+ 匹配连续的逗号和空格
'''
codeend
解析正则表达式 实例：将字符串转换成列表<a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/解析正则表达式.py">试-下...</a>
code####start
解析正则表达式 r'/(\d+)_([^/]+)b$' 
# -*- coding: UTF-8 -*-
#匹配正整数
import re  
str=r'/(\d+)_([^/]+)b$'  
if re.match(str,'/163_goodb'):  #OK
  print('OK')
else:
  print('No')             
'''
'/(\d+)_([^/]+)b$'  解析：
'/' 匹配开始字符
() 提取匹配的字符串。
[] 定义匹配的字符范围。
^开头或取反
\d+ 匹配连续的0-9数
_    匹配下划线
([^/]+) 匹配除‘/’以外的任何字符
$ 匹配一个字符串的结尾,比如 (b$) 就是匹配以字母b结尾的字符串.
/(\d+)_([^/]+)b$ 匹配  /连续的0-9数_以b结尾的字符串 例如：/163_goodb
''' 
codeend               

使用re.split
语法：
code####start
re.split(pattern, string, maxsplit=0)
通过正则表达式将字符串分离。如果用括号将正则表达式括起来，那么匹配的字符串也会被列入到list中返回。
maxsplit是分离的次数，maxsplit=1分离一次，默认为0，不限制次数。
codeend
re.split实例1：将字符串转换成列表 <a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/正则表达式匹配一个或连续逗号空格split.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re
str = 'a,b,, ,,c  d'
print re.split('[, ]+',str)
'''
运行结果：
['a', 'b', 'c', 'd']
'''
codeend

re.split实例2： 多个分割符将字符串形成列表 <a href="/runtool/runpyget/?f=account/templates/runtool/pythonfile/多个分割符将字符串形成列表正则表达式.py">试-下...</a>
code####start
# -*- coding: UTF-8 -*-
import re  
str=r'/(\d+)_([^/]+)b$' 
print re.split(str,"/163_goodb") 
'''
运行结果：
['', '163', 'good', '']
() 的作用是提取匹配的字符串。
/ _ b为分割符
'''
codeend
正则表达式修饰符 - 可选标志
正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：
code####start
修饰符   描述
re.I    使匹配对大小写不敏感
re.L    做本地化识别（locale-aware）匹配
re.M    多行匹配，影响 ^ 和 $
re.S    使 . 匹配包括换行在内的所有字符
re.U    根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X    该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。
codeend
正则表达式模式
模式字符串使用特殊的语法来表示一个正则表达式：
字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。
多数字母和数字前加一个反斜杠时会拥有不同的含义。
标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。
反斜杠本身需要使用反斜杠转义。
由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 '\\t')匹配相应的特殊字符。
下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。
code####start
模式         描述
^           匹配字符串的开头
$           匹配字符串的末尾。
.           匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
[...]       用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
[^...]      不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
re*         匹配0个或多个的表达式。
re+         匹配1个或多个的表达式。
re?         匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
re{n}  
re{n,}      精确匹配n个前面表达式。
re{n, m}    匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
a| b        匹配a或b
(re)        G匹配括号内的表达式，也表示一个组
(?imx)      正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
(?-imx)     正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?: re)     类似 (...), 但是不表示一个组
(?imx: re)  在括号中使用i, m, 或 x 可选标志
(?-imx: re) 在括号中不使用i, m, 或 x 可选标志
(?#...)     注释.
(?= re)     前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
(?! re)     前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
(?> re)     匹配的独立模式，省去回溯。
\w          匹配字母数字及下划线
\W          匹配非字母数字及下划线
\s          匹配任意空白字符，等价于 [\t\n\r\f].
\S          匹配任意非空字符
\d          匹配任意数字，等价于 [0-9].
\D          匹配任意非数字
\A          匹配字符串开始
\Z          匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c
\z          匹配字符串结束
\G          匹配最后匹配完成的位置。
\b          匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B          匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\n, \t,     等.  匹配一个换行符。匹配一个制表符。等
\1...\9     匹配第n个分组的内容。
\10         匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。
codeend

正则表达式实例
字符匹配
code####start
实例          描述
python       匹配 "python".
codeend
字符类
code####start
实例         描述
[Pp]ython   匹配 "Python" 或 "python"
rub[ye]     匹配 "ruby" 或 "rube"
[aeiou]     匹配中括号内的任意一个字母
[0-9]       匹配任何数字。类似于 [0123456789]
[a-z]       匹配任何小写字母
[A-Z]       匹配任何大写字母
[a-zA-Z0-9] 匹配任何字母及数字
[^aeiou]    除了aeiou字母以外的所有字符
[^0-9]      匹配除了数字外的字符
codeend
特殊字符类
code####start
实例    描述
.      匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。
\d     匹配一个数字字符。等价于 [0-9]。
\D     匹配一个非数字字符。等价于 [^0-9]。
\s     匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S     匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\w     匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W     匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
codeend

